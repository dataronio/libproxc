
void chan_send( chan, end )
{
    lk = chan.spinlock;

    if ( chan.closed ) {
        return;
    }

    rx_end = pop( chan.rx_end );
    if ( rx_end != nullptr && ( rx_end.alt == nullptr || rx_end.alt.try_select( blocking ) ) )
    {
        // item must be consumed and consumed flag set to true
        // before rx is scheduled.
        rx_end.item = move( end.item );
        chan.rx_consumed = true;
        scehdule( rx_end.ctx );
        return Ok;
    }

    chan.tx_end = end;
    wait( lk );
    // Tx has consumed item if rx_consumed set true,
    // else the channel is closed. The reasoning is that
    // this channel end is only woken up by the other end if
    // the operation completed or the channel closed. Even though
    // the channel might have been closed immediately after the
    // operation completed, the operation will be registered by
    // the boolean flag.
    return ( chan.tx_consumed.exchange( false ) )
        ? Ok
        : Closed ;
}

void chan_recv( chan, end )
{
    lk = chan.spinlock;

    if ( chan.closed() ) {
        return;
    }

    tx_end = pop( chan.tx_end );
    if ( tx_end != nullptr && ( tx_end.alt == nullptr || tx_end.alt.try_select( blocking ) ) )
    {
        // item must be consumed and consumed flag set to true
        // before rx is scheduled.
        end.item = move( tx_end.item );
        chan.tx_consumed = true;
        scehdule( tx_end.ctx );
        return Ok;
    }

    chan.rx_end = end;
    wait( lk );
    // Tx has consumed item if rx_consumed set true,
    // else the channel is closed. The reasoning is that
    // this channel end is only woken up by the other end if
    // the operation completed or the channel closed. Even though
    // the channel might have been closed immediately after the
    // operation completed, the operation will be registered by
    // the boolean flag.
    return ( chan.rx_consumed.exchange( false ) )
        ? Ok
        : Closed ;
}

void enter( chan, end )
{
    // no spinlock
    chan.{tx/rx}_end = end;
}

void leave( chan )
{
    if ( chan.{tx/rx}_end == nullptr ) {
        return;
    }
    // spinlock here to ensure the channel end is not
    // used after the alting process has ended.
    lk = chan.spinlock;
    chan.{tx/rx}_end = nullptr;
}

bool ready( chan )
{
    // no spinlock
    if ( chan.is_closed ) {
        // FIXME: return true?
        return false;
    }
    {tx,rx}_end = chan.{tx,rx}_end;
    return {tx,rx}_end != nullptr;
    // checking that the end is not ready on the same alt
    // is and should be done by the alt before entering happens
}

bool chan_alt_send( chan )
{
    // this is to avoid deadlocks when both Tx and Rx is alting.
    // SyncGuard will try to test-and-set the atomic flag. If
    // it fails, the other end is alting and is currently trying to
    // complete this channel operation. The SyncGuard will set the
    // clear the atomic flag at function exit if it managed to test-and-set it.
    SyncGuard guard{ chan.alt_sync_ };
    if ( guard.clashed() ) {
        return false;
    }

    // locking the channel spinlock is now safe, as the only possibility
    // of a deadlock is when both Tx and Rx is alting, and only one of them
    // can be completing the channel operation because only one will be
    // able to acquire the sync guard.
    lk = chan.spinlock;

    if ( chan.is_closed() ) {
        return false;
    }

    rx_end = chan.rx_end;
    if ( rx_end != nullptr ) {
        if ( rx_end.alt == nullptr || rx_end.alt.try_select( blocking ) ) {
            // Rx is either not alting, or it is alting and
            // it "won" the selection. Either way, complete the
            // operation.
            chan.tx_end = nullptr;
            chan.rx_end = nullptr;
            rx_end.item = move( item );
            chan.rx_consumed = true;
            scehdule( rx_end.ctx );
            return true;

        } else {
            return false;
        }

    } else {
        return false;
    }
}

bool chan_alt_recv( chan, item )
{
    // this is to avoid deadlocks when both Tx and Rx is alting.
    // SyncGuard will try to test-and-set the atomic flag. If
    // it fails, the other end is alting and is currently trying to
    // complete this channel operation. The SyncGuard will clear the
    // atomic flag at function exit if it managed to test-and-set it.
    SyncGuard guard{ chan.alt_sync_ };
    if ( guard.clashed() ) {
        return false;
    }

    // locking the channel spinlock is now safe, as the only possibility
    // of a deadlock is when both Tx and Rx is alting, and only one of them
    // can be completing the channel operation because only one will be
    // able to acquire the sync guard.
    lk = chan.spinlock;

    tx_end = chan.tx_end;
    if ( tx_end == nullptr ) {
        return false;
    }

    tx_end = chan.tx_end;
    if ( tx_end != nullptr ) {
        if ( tx_end.alt == nullptr || tx_end.alt.try_select( blocking ) ) {
            // Tx is either not alting, or it is alting and
            // it "won" the selection. Either way, complete the
            // operation.
            chan.rx_end = nullptr;
            chan.tx_end = nullptr;
            item = move( tx_end.item );
            chan.tx_consumed = true;
            scehdule( tx_end.ctx );
            return true;

        } else {
            return false;
        }

    } else {
        return false;
    }
}

