
// Rx always completes channel comm
// Non-alting ends must be signaled by alting ends
// Rx cleans up ends

// Tx will always wait for Rx.
// 3 cases exists:
//      1: No Rx. Tx waits until an Rx consumes the item
//         and wakes up Tx, then returns. This applies for
//         both alting and non-alting. If alting Rx
//         chooses this Tx, then it is an auto-sync and
//         waking up Tx is a side-effect of the syncing.
//      2: Normal Rx. Tx wakes up Rx, waits for it to
//         consume the item, and returns. No syncing
//         needed.
//      3: Alting Rx. Tx tries to wake up Rx and waits.
//         One of two things happen:
//           Either, the alting Rx syncs with this Tx,
//             the item is consumed, Tx is woken up, and
//             returns.
//           Or, the alting Rx does not sync with this Tx,
//             and this Tx will wait until next Rx
//             arrives. This Rx will consume the item, and
//             wakeup Tx. Tx will then return.
void chan_send( chan, end, item )
{
    lk = chan.spinlock;

    if ( chan.closed ) {
        return;
    }

    rx_end = pop( chan.rx_end );
    if ( rx_end != nullptr ) {
        if ( rx_end.alt == nullptr
            || rx_end.alt.try_select() ) {
            rx_end.item = move( item );
            chan.rx_consumed = true;
            scehdule( rx_end.ctx );
            return Ok;
        }
    }

    chan.tx_end = { running_ctx, item };
    wait( lk );
    // Rx has consumed item if tx_consumed set true
    if ( chan.tx_consumed.exchange( false ) ) {
        return Ok;
    } else {
        return Closed;
    }
}

// Rx always consumes item and always wakes up Tx,
// in this order.
// 3 cases exists:
//      1: No Tx. Rx commits end, and waits. When woken
//         up, a Tx is ready. Then, case 2 or case 3
//         happens.
//      2: Normal Tx. Item is consumed, tx is woken up,
//         and returns.
//      3: Alting Tx. Rx commits end, may wake up Tx, and
//         waits. When woken up, one of two thins happen:
//           Either, the alting Tx syncs with this Rx, the
//             item is consumed, the alting Tx is woken
//             up, and returns.
//           Or, the alting Tx does not sync with this Rx.
//             This Rx is then woken up when either the
//             same alting Tx syncs, the same alting Tx
//             syncs with another case and leaves this Rx
//             unsynced, or another Tx comes around and
//             wakes up Rx. Then, cases 1, 2, or 3 happens.
void chan_recv( chan, end, item & )
{
    lk = chan.spinlock;

    if ( chan.closed() ) {
        return;
    }

    tx_end = pop( chan.tx_end );
    if (   tx_end != nullptr
        && (    tx_end.alt == nullptr
             || tx_end.alt.try_select() ) )
    {
        item = move( tx_end.item );
        chan.tx_consumed = true;
        scehdule( tx_end.ctx );
        return Ok;
    }

    chan.rx_end = { running_ctx, item };
    wait( lk );
    // Tx has consumed item if rx_consumed set true
    if ( chan.rx_consumed.exchange( false ) ) {
        return Ok;
    } else {
        return Closed;
    }
}

void enter( chan, end )
{
    lk = chan.spinlock;
    chan.{tx/rx}_end = end;
}

void leave( chan )
{
    lk = chan.spinlock;
    chan.{tx/rx}_end = nullptr;
}

bool ready( chan )
{
    lk = chan.spinlock;

    if ( chan.is_closed ) {
        // FIXME: return true?
        return false;
    }
    {tx,rx}_end = chan.{tx,rx}_end;
    return {tx,rx}_end != nullptr;
    // checking that the end is not ready on the same alt
    // is and should be done by the alt before entering happens
}

// 3 cases exists:
//      1: No Rx.
//      2: Normal Rx.
//      3: Alting Rx.
bool chan_alt_send( chan, item )
{
    lk = chan.spinlock;

    if ( chan.is_closed() ) {
        return false;
    }

    rx_end = chan.rx_end;
    if ( rx_end != nullptr ) {
        if ( rx_end.alt == nullptr
            || rx_end.alt.try_select() )
        {
            chan.tx_end = nullptr;
            chan.rx_end = nullptr;
            rx_end.item = move( item );
            chan.rx_consumed = true;
            scehdule( rx_end.ctx );
            return true;

        } else {
            return false;
        }

    } else {
        return false;
    }
}

// 3 cases exists:
//      1: No Tx.
//      2: Normal Tx.
//      3: Alting Tx.
bool chan_alt_recv( chan, item )
{
    lk = chan.spinlock;

    tx_end = chan.tx_end;
    if ( tx_end == nullptr ) {
        return false;
    }

    tx_end = chan.tx_end;
    if ( tx_end != nullptr ) {
        if ( tx_end.alt == nullptr
            || tx_end.alt.try_select() )
        {
            chan.rx_end = nullptr;
            chan.tx_end = nullptr;
            item = move( tx_end.item );
            chan.tx_consumed = true;
            scehdule( tx_end.ctx );
            return true;

        } else {
            return false;
        }

    } else {
        return false;
    }
}

