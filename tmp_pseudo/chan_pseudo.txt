
// Rx always completes channel comm
// Non-alting ends must be signaled by alting ends
// Rx cleans up ends

// Tx will always wait for Rx.
// 3 cases exists:
//      1: No Rx. Tx waits until an Rx consumes the item
//         and wakes up Tx, then returns. This applies for
//         both alting and non-alting. If alting Rx
//         chooses this Tx, then it is an auto-sync and
//         waking up Tx is a side-effect of the syncing.
//      2: Normal Rx. Tx wakes up Rx, waits for it to
//         consume the item, and returns. No syncing
//         needed.
//      3: Alting Rx. Tx tries to wake up Rx and waits.
//         One of two things happen:
//           Either, the alting Rx syncs with this Tx,
//             the item is consumed, Tx is woken up, and
//             returns.
//           Or, the alting Rx does not sync with this Tx,
//             and this Tx will wait until next Rx
//             arrives. This Rx will consume the item, and
//             wakeup Tx. Tx will then return.
void chan_send( chan, end, item )
{
    lk = chan.spinlock;

    if ( chan.closed ) {
        return;
    }

    chan.tx_end = { runnin_ctx, item };

    rx_end = pop( chan.rx_end );
    if ( rx_end != nullptr ) {
        if ( rx_end.alting ) {
            rx_end.alting.maybe_wakeup;
        } else {
            schedule( rx_end.ctx );
        }
    }

    wait( lk );
    // here, Rx has consumed item
}

// Rx always consumes item and always wakes up Tx,
// in this order.
// 3 cases exists:
//      1: No Tx. Rx commits end, and waits. When woken
//         up, a Tx is ready. Then, case 2 or case 3
//         happens.
//      2: Normal Tx. Item is consumed, tx is woken up,
//         and returns.
//      3: Alting Tx. Rx commits end, may wake up Tx, and
//         waits. When woken up, one of two thins happen:
//           Either, the alting Tx syncs with this Rx, the
//             item is consumed, the alting Tx is woken
//             up, and returns.
//           Or, the alting Tx does not sync with this Rx.
//             This Rx is then woken up when either the
//             same alting Tx syncs, the same alting Tx
//             syncs with another case and leaves this Rx
//             unsynced, or another Tx comes around and
//             wakes up Rx. Then, cases 1, 2, or 3 happens.
void chan_recv( chan, end, item & )
{
    lk = chan.spinlock;
    loop {
        if ( chan.closed() ) {
            return;
        }

        tx_end = chan.tx_end;

        if ( tx_end != nullptr ) {
            if ( tx_end.alting && ! chan.alt_sync ) {
                // order matters here
                chan.rx_end = { running_ctx };
                tx_end.alting.maybe_wakeup;

                wait( lk, true );

                if ( ! chan.alt_sync ) {
                    continue;
                }
                // alting Tx synced, can now consume item
            }

            chan.tx_end = nullptr;
            // order matters here
            item = tx_end.item;
            schedule( tx_end.ctx );
            return;
        }

        chan.end_rx = { running_ctx };
        wait( lk, true );
        // Tx should be ready
    }
}

void enter( chan, alt )
{
    lk = chan.spinlock;
    // Tx, FIXME: what about expensive copies of item?
    chan.tx_end = { running_ctx, item, alt };
    // Rx
    chan.rx_end = { running_ctx, alt };
    chan.alt_sync = false;
}

void leave( chan )
{
    lk = chan.spinlock;
    // Tx
    chan.tx_end = nullptr;
    // Rx
    chan.rx_end = nullptr;
    chan.alt_sync = false;
}

bool ready( chan, alt )
{
    lk = chan.spinlock;
    if ( chan.is_closed ) {
        // FIXME: return true?
        return false;
    }
    {tx,rx}_end = chan.{tx,rx}_end;
    return {tx,rx}_end != nullptr
        && {tx,rx}_end.alting != alt;
}

// 3 cases exists:
//      1: No Rx.
//      2: Normal Rx.
//      3: Alting Rx.
bool chan_alt_tx_sync( chan )
{
    lk = chan.spinlock;

    rx_end = chan.rx_end;
    if ( rx_end != nullptr ) {
        return false;
    }

    if ( rx_end.alting ) {
        if ( chan.alt_sync ) {
            // accept the sync
            schedule( rx_end.ctx );

            wait( lk );
            // Rx consumed item
            return true;

        } else {
            // offer sync
            chan.alt_sync = true;
            rx_end.alting.maybe_wakeup();
            wait( lk );
            // if chan.alt_sync true, Rx consumed item
            return chan.alt_sync;
        }

    } else {
        chan.alt_sync = true;
        schedule( rx_end.ctx );

        wait( lk );
        // Rx consumed item
        return true;
    }
}

// 3 cases exists:
//      1: No Tx.
//      2: Normal Tx.
//      3: Alting Tx.
bool chan_alt_rx_sync( chan )
{
    lk = chan.spinlock;

    tx_end = chan.tx_end;
    if ( tx_end != nullptr ) {
        return false;
    }

    if ( tx_end.alting ) {
        if ( chan.alt_sync ) {
            // accept the sync
            chan.tx_end = nullptr;
            // Order matters here.
            chan.rx_end.item = tx_end.item;
            schedule( tx_end.ctx );
            return true;

        } else {
            // offer sync
            chan.alt_sync = true
            tx_end.alting.maybe_wakeup();
            wait( lk );

            if ( ! chan.alt_sync ) {
                return false;
            }

            chan.tx_end = nullptr;
            // Order matters here.
            chan.rx_end.item = tx_end.item;
            schedule( tx_end.ctx );
            return true;
        }

    } else {
        // doesn't need to set alt_sync, as waking up tx
        // is a side-effect of syncing.
        chan.tx_end = nullptr;
        // Order matters here.
        chan.rx_end.item = tx_end.item;
        schedule( tx_end.ctx );
        return true;
    }
}

